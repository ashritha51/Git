import cors from "cors";
import express, { json } from "express";
import { Schema, connect, model } from "mongoose";

const PORT = 3000;

const app = express();
app.use(cors());
app.use(json());

// Section schema
const SectionSchema = new Schema({
  _id: String,
  timetable: [[String]], // 2D array of strings
  allocationMap: {
    type: Map,
    of: [[Number]], // Array of [row, col] positions
    default: () => new Map(), // Ensure default is a valid Map
  },
});

const Section = model("Section", SectionSchema);

const isSafe = (row, col, timetable, subject) => {
  if (timetable[row][col] !== ".") return false;

  let columnCount = 0;
  timetable.forEach((rowArr) => {
    if (rowArr[col] === subject) {
      columnCount++;
    }
  });
  if (columnCount >= 1) return false;

  if (timetable[row].includes(subject)) return false;

  return true;
};
const shuffleArray = (array) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
  }
};

const isRowEmptyInCols = (timetable, row, startCol, endCol) => {
  let val = true;
  for (let col = startCol; col <= endCol; col++) {
    if (timetable[row][col] !== ".") {
      val = false;
      break;
    }
  }
  return val;
};

const checkPrevLabs = (allSections, item, row, startCol, endCol, lab) => {
  for (let allsec of allSections) {
    if (allsec._id !== item.section) {
      for (let [secSubjects, positions] of allsec.allocationMap.entries()) {
        if (secSubjects !== lab) continue;
        for (let [r, c] of positions) {
          if (r === row && c >= startCol && c <= endCol) {
            return false;
          }
        }
      }
    }
  }
  return true;
};

const checkPrev = (allSections, item, row, col, subject) => {
  for (let allsec of allSections) {
    if (allsec._id !== item.section) {
      for (let [secSubjects, positions] of allsec.allocationMap.entries()) {
        if (secSubjects !== subject) continue;
        for (let [r, c] of positions) {
          if (r === row && c === col) {
            return false;
          }
        }
      }
    }
  }
  return true;
};


const reallocateLab = (subject, startCol, endCol, allSections, item, timetable, allocationMap, book) => {

  console.log(`Reallocating lab: ${subject} in columns ${startCol} - ${endCol}`);

  // Find the current row where the lab is placed
  let currentRow = -1;
  for (let [row, col] of allocationMap.get(subject) || []) {
    if (col >= startCol && col <= endCol) {
      currentRow = row;
      break;
    }
  }

  if (currentRow === -1) {
    console.error(`Lab ${subject} is not currently allocated in the expected columns.`);
    return;
  }

  // Try to find a new row (excluding the current row)
  for (let row = 0; row < timetable.length; row++) {
    if (row === currentRow) continue; // Skip the current row

    // Check if the row is free in the required columns and has no conflicts
    if (
      isRowEmptyInCols(timetable, row, startCol, endCol) &&
      checkPrevLabs(allSections, item, row, startCol, endCol, subject) &&
      book[row] === 0
    ) {
      console.log(`Moving lab ${subject} from row ${currentRow} to row ${row}`);

      // Clear the lab from the old row
      for (let col = startCol; col <= endCol; col++) {
        timetable[currentRow][col] = ".";
      }

      // Assign the lab to the new row
      for (let col = startCol; col <= endCol; col++) {
        timetable[row][col] = subject;
      }

      // Update allocation map
      allocationMap.set(subject, allocationMap.get(subject).map(([r, c]) =>
        (c >= startCol && c <= endCol ? [row, c] : [r, c])
      ));

      // Mark the row as occupied
      book[currentRow] = 0; // Release old row
      book[row] = -1; // Mark new row as occupied
      return;
    }
  }

  console.error(`Failed to reallocate lab: ${subject}, no suitable row found.`);
};


const reallocate = async (
  isLab,
  allocationCount,
  allocationMap,
  currsubject,
  sectionId,
  timetable,
  allSections,
  item
) => {
  const keysArray = Array.from(allocationMap.keys());
  let idx = 2;

  while (idx <= keysArray.length) {
    const lastKey = keysArray[keysArray.length - idx];
    console.log("I am in reallocate method. Current Key:", lastKey);

    if (isLab) {
      console.log(`Skipping reallocation for lab: ${lastKey}`);
      idx++;
      continue;
    }

    const values = allocationMap.get(lastKey);
    console.log("Values are:", values);

    if (!values || values.length === 0) {
      console.error("No positions found for lastKey:", lastKey);
      idx++;
      continue;
    }

    console.log("Current subject:", currsubject);

    let allocated = false;
    for (let row = 0; row < timetable.length && !allocated; row++) {
      for (let col = 0; col < timetable[row].length && !allocated; col++) {
        if (timetable[row][col] === ".") {
          for (let i = 0; i < values.length && !allocated; i++) {
            const [r, c] = values[i];
            console.log("r:", r, "c:", c, "row:", row, "col:", col);

            timetable[r][c] = ".";
            if (
              isSafe(r, c, timetable, currsubject) &&
              checkPrev(allSections, item, r, c, currsubject) &&
              isSafe(row, col, timetable, lastKey) &&
              checkPrev(allSections, item, row, col, lastKey)
            ) {
              console.log("In isSafe for subject:", lastKey);

              timetable[r][c] = currsubject;
              timetable[row][col] = lastKey;

              allocationCount++;
              allocationMap.set(currsubject, [
                ...(allocationMap.get(currsubject) || []),
                [r, c],
              ]);
              allocationMap.set(
                lastKey,
                [
                  ...(allocationMap.get(lastKey) || []),
                  [row, col],
                ].filter(([vr, vc]) => !(vr === r && vc === c))
              );

              console.log(`Swapped: (${r}, ${c}) with (${row}, ${col})`);

              sectionId.timetable = timetable;
              sectionId.allocationMap = allocationMap;
              break;
            } else {
              timetable[r][c] = lastKey;
            }
          }
          idx++;
        }
        if (allocationCount === 3) break;
      }
    }

    if (allocationCount === 3) break;
  }
};


const allocateSec = async (
  sectionId,
  faculties,
  isLab,
  allocationMap,
  timetable,
  book,
  count_lab,
  allSections,
  item
) => {
  console.log(`type....${typeof (faculties)}.....faculties.....${faculties}`)
  console.log(`Starting allocation for faculties: ${faculties.join(', ')}, isLab: ${isLab}`);

  if (isLab) {
    //! Lab allocation logic
    // const allocateLab = (facultyIds, startCol, endCol) => {
    //   //const facultyList = faculties.join(',');
    //   //lab = lab.toString();
    //   const rows = [0, 1, 2, 3, 4]; // All available rows
    //   shuffleArray(rows);

    //   let rowAllocated = false;
    //   for (let row of rows) {
    //     console.log(`Checking row: ${row} for columns ${startCol} - ${endCol}.`);
    //     if (rowAllocated) break;

    //     // Check if the specified columns are empty and the row is not already allocated
    //     const isRowOccupied = timetable[row].some(
    //       (cell, colIndex) => colIndex >= startCol && colIndex <= endCol && cell !== "."
    //     );


    //     console.log(isRowEmptyInCols(timetable, row, startCol, endCol));
    //     if (
    //       !isRowOccupied &&
    //       isRowEmptyInCols(timetable, row, startCol, endCol) &&
    //       checkPrevLabs(allSections, item, row, startCol, endCol, lab) &&
    //       book[row] === 0
    //     ) {
    //       console.log(
    //         `Allocating lab in row: ${row}, columns ${startCol} - ${endCol}.`
    //       );


    //       let assignedPositions = []; // Store assigned positions for reuse
    //       for (let col = startCol; col <= endCol; col++) {
    //         // timetable[row][col] = facultyList;
    //         timetable[row][col] = facultyIds[0]; // Use first faculty ID for storage
    //         assignedPositions.push([row, col]);
    //       }
    //       // Assign the same positions to each faculty ID
    //       facultyIds.forEach(facultyId => {
    //         if (!allocationMap.has(facultyId.toString())) {
    //           allocationMap.set(facultyId.toString(), []);
    //         }
    //         allocationMap.get(facultyId.toString()).push(...assignedPositions);
    //       });

    //       if (startCol === 0) count_lab[0]++;
    //       else if (endCol === 3) count_lab[1]++;




    //       //for (let col = startCol; col <= endCol; col++) {
    //       book[row] = -1; // Mark only these columns
    //       //}
    //       rowAllocated = true;
    //       console.log("Updated allocationMap:", Object.fromEntries(allocationMap));
    //       break;
    //     }
    //   }

    //   if (!rowAllocated) {
    //     throw new Error(
    //       `Unable to allocate lab in columns ${startCol} - ${endCol}.`
    //     );
    //   }
    // };

    const allocateLab = (facultyIds, startCol, endCol) => {
      const facultyList = facultyIds.join(',');
      console.log("fac list", facultyList)

      const rows = [0, 1, 2, 3, 4]; // Available rows
      shuffleArray(rows);

      let rowAllocated = false;
      for (let row of rows) {
        console.log(`Checking row: ${row} for columns ${startCol} - ${endCol}.`);

        const isRowOccupied = timetable[row].some(
          (cell, colIndex) => colIndex >= startCol && colIndex <= endCol && cell !== "."
        );

        const isRowAvailable = !isRowOccupied && book[row] === 0;

        console.log({
          row,
          isRowOccupied,
          bookStatus: book[row],
          isRowAvailable
        });

        if (isRowAvailable) {
          console.log(`✅ Allocating lab for ${facultyIds} in row: ${row}, columns ${startCol} - ${endCol}.`);

          let assignedPositions = []; // Store assigned positions

          for (let col = startCol; col <= endCol; col++) {
            timetable[row][col] = facultyList // Store first faculty ID
            assignedPositions.push([row, col]);
          }
          console.log("facutlyIds", facultyIds)
          // Assign positions to each faculty ID in the array
          facultyIds.forEach(facultyId => {
            console.log("id ", facultyIds)
            if (!allocationMap.has(facultyId.toString())) {
              allocationMap.set(facultyId.toString(), []);
            }
            allocationMap.get(facultyId.toString()).push(...assignedPositions);
          });
          if (startCol === 0) count_lab[0]++;
          else if (startCol === 3) count_lab[1]++;

          book[row] = -1; // Mark row as booked
          rowAllocated = true;
          console.log("🔷 Updated allocationMap:", Object.fromEntries(allocationMap));
          break;
        }
      }

      if (!rowAllocated) {
        console.error(`❌ Lab allocation failed for faculties: ${facultyIds}`);
      }
    };


    const sectionNumber = Number(sectionId.id || sectionId.number || sectionId);
    const isEvenSection = sectionNumber % 2 === 0;

    console.log("is lab even ", isEvenSection, typeof sectionId);

    // Define morning and afternoon limits based on even/odd section
    const morningLimit = isEvenSection ? 2 : 3;
    const afternoonLimit = isEvenSection ? 3 : 2;

    var count = 0;
    var isLabAllocatedSucess = false;
    try {
      while (count < 5 && !isLabAllocatedSucess) {
        // for (const faculty of faculties) {
        if (count_lab[0] < morningLimit) {
          allocateLab(faculties, 0, 2);
          isLabAllocatedSucess = true;
          break;
        }
        if (count_lab[1] < afternoonLimit) {
          allocateLab(faculties, 3, 5);
          isLabAllocatedSucess = true;
          break;
        }
        // }
        count++;
      }
      if (count >= 5 && !isLabAllocatedSucess) {
        console.log("Lab needed to be reallocated");
        for (const faculty of faculties) { // Reallocate for each faculty in the array
          reallocateLab(faculty, 0, 5, allSections, item, item, timetable, allocationMap, book)
        }
      }
    }
    catch (error) {
      console.error(`Initial lab allocation failed for faculties: ${faculties.join(', ')}, error`);
    }
    console.log("Allocation lab", allocationMap);

    sectionId.timetable = timetable;
    sectionId.allocationMap = allocationMap;
  } else {
    console.log(`Allocating non - lab subject: ${faculties[0]}`);
    let allocationCount = 0;
    const subject = faculties[0].toString();

    for (let row = 0; row < timetable.length; row++) {
      for (let col = 0; col < timetable[row].length; col++) {
        if (
          isSafe(row, col, timetable, subject) &&
          checkPrev(allSections, item, row, col, subject)
        ) {
          timetable[row][col] = subject;
          allocationCount++;
          console.log(
            `Allocated subject: ${subject} at row: ${row}, col: ${col}`
          );

          if (!allocationMap.has(subject)) allocationMap.set(subject, []);
          allocationMap.get(subject).push([row, col]);

          if (allocationCount === 3) break;
        }
      }

      if (allocationCount === 3) {
        break;
      }
    }

    sectionId.timetable = timetable;
    sectionId.allocationMap = allocationMap;

    if (allocationCount < 3) {
      console.log(
        `Subject: ${subject} allocation incomplete.Attempting reallocation.`
      );
      await reallocate(
        isLab,
        allocationCount,
        allocationMap,
        subject,
        sectionId,
        timetable,
        allSections,
        item
      );
      sectionId.timetable = timetable;
      sectionId.allocationMap = allocationMap;
    }

    console.log(`Allocation completed for non - lab subject: ${subject}`);
  }

  return { timetable, allocationMap };
};

app.post("/allocate", async (req, res) => {
  console.log("Received allocation request");
  const data = req.body;
  console.log("data is ", data)
  try {
    for (const item of data) {
      console.log(`Processing section: ${item.section}${typeof (item.section)}`);
      let sec = await Section.findById(item.section);
      if (!sec) {
        console.log(`Section: ${item.section} not found. Initializing.`);
        const initialTimetable = Array.from({ length: 5 }, () => Array(6).fill("."));
        sec = new Section({
          _id: item.section,
          timetable: initialTimetable,
        });
        await sec.save();
      }

      const book = new Array(5).fill(0);
      const count_lab = new Array(2).fill(0);
      const timetable = sec.timetable;
      let allocationMap = sec.allocationMap || new Map();
      const allSections = await Section.find();

      const labSubjects = item.orderedSubjects.filter((sub) => sub.isLab);
      const nonLabSubjects = item.orderedSubjects.filter((sub) => !sub.isLab);

      for (const { facultyId, isLab } of labSubjects) {
        await allocateSec(
          sec,
          facultyId,
          isLab,
          allocationMap,
          timetable,
          book,
          count_lab,
          allSections,
          item
        );
      }

      for (const { facultyId, isLab } of nonLabSubjects) {
        await allocateSec(
          sec,
          facultyId,
          isLab,
          allocationMap,
          timetable,
          book,
          count_lab,
          allSections,
          item
        );
      }

      await sec.save();
      console.log("Allocation completed for section:", item.section);
      console.table(timetable);
      console.log("allocation map...........", allocationMap)

    }
    const allSections = await Section.find({}, { _id: 1, timetable: 1 });
    const timetable = allSections.timetable;  // Access the timetable array of objects
    console.log("timetable", timetable);
    res.status(200).json({ message: "Allocation successful" });
    console.log("Allocation request processed successfully");
  } catch (err) {
    console.error("Error during allocation:", err);
    res.status(500).json({
      message: "Error occurred during allocation",
      error: err.message,
    });
  }
});


//! get the section timetable display
app.get("/tt/:sectionId", async (req, res) => {
  const { sectionId } = req.params;
  try {
    const section = await Section.findById(sectionId);
    if (!section) {
      return res.status(404).json({ message: "Section not found" });
    }
    res.status(200).json({ timetable: section.timetable });
  } catch (err) {
    console.error("Error fetching timetable:", err);
    res.status(500).json({ message: "Error occurred while fetching timetable", error: err.message });
  }
});

//!  get the individual faculty timetable
app.get("/ft/:subjectId", async (req, res) => {
  const { subjectId } = req.params;
  console.log("Received subjectId:", subjectId);

  try {
    const sections = await Section.find(); // Get all sections

    // Filter sections where the subjectId is present in the timetable
    const result = sections.map((section) => {
      const timetable = section.timetable;
      const matchingSlots = []; // Store matching slots

      timetable.forEach((row, rowIndex) => {
        row.forEach((slot, colIndex) => {
          if (slot === subjectId) {
            matchingSlots.push({
              row: rowIndex,
              col: colIndex,
              section: section._id,
            });
          }
        });
      });

      if (matchingSlots.length > 0) {
        return {
          sectionId: section._id,
          matchingSlots: matchingSlots,
        };
      }
      return null; // If no matching slots, return null
    }).filter((item) => item !== null); // Remove null results

    if (result.length === 0) {
      return res.status(404).json({ message: "No timetable found for this subject." });
    }

    res.json({ subjectTimetable: result }); // Send the filtered result
  } catch (error) {
    console.error("Error fetching subject timetable:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
});







// MongoDB connection and server start
connect("mongodb://localhost:27017/school", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
  .then(() => {
    console.log("Connected to MongoDB");
    app.listen(3000, () => {
      console.log("Server is running on port 3000");
    });
  })
  .catch((error) => {
    console.error("MongoDB connection error:");
  });

























   // const allocateLab = (facultyIds, startCol, endCol) => {
    //   //const facultyList = faculties.join(',');
    //   //lab = lab.toString();
    //   const rows = [0, 1, 2, 3, 4]; // All available rows
    //   shuffleArray(rows);

    //   let rowAllocated = false;
    //   for (let row of rows) {
    //     console.log(`Checking row: ${row} for columns ${startCol} - ${endCol}.`);
    //     if (rowAllocated) break;

    //     // Check if the specified columns are empty and the row is not already allocated
    //     const isRowOccupied = timetable[row].some(
    //       (cell, colIndex) => colIndex >= startCol && colIndex <= endCol && cell !== "."
    //     );


    //     console.log(isRowEmptyInCols(timetable, row, startCol, endCol));
    //     if (
    //       !isRowOccupied &&
    //       isRowEmptyInCols(timetable, row, startCol, endCol) &&
    //       checkPrevLabs(allSections, item, row, startCol, endCol, lab) &&
    //       book[row] === 0
    //     ) {
    //       console.log(
    //         `Allocating lab in row: ${row}, columns ${startCol} - ${endCol}.`
    //       );


    //       let assignedPositions = []; // Store assigned positions for reuse
    //       for (let col = startCol; col <= endCol; col++) {
    //         // timetable[row][col] = facultyList;
    //         timetable[row][col] = facultyIds[0]; // Use first faculty ID for storage
    //         assignedPositions.push([row, col]);
    //       }
    //       // Assign the same positions to each faculty ID
    //       facultyIds.forEach(facultyId => {
    //         if (!allocationMap.has(facultyId.toString())) {
    //           allocationMap.set(facultyId.toString(), []);
    //         }
    //         allocationMap.get(facultyId.toString()).push(...assignedPositions);
    //       });

    //       if (startCol === 0) count_lab[0]++;
    //       else if (endCol === 3) count_lab[1]++;




    //       //for (let col = startCol; col <= endCol; col++) {
    //       book[row] = -1; // Mark only these columns
    //       //}
    //       rowAllocated = true;
    //       console.log("Updated allocationMap:", Object.fromEntries(allocationMap));
    //       break;
    //     }
    //   }

    //   if (!rowAllocated) {
    //     throw new Error(
    //       `Unable to allocate lab in columns ${startCol} - ${endCol}.`
    //     );
    //   }
    // };








    //samplesend+fetching



    document.addEventListener("DOMContentLoaded", () => {

    // Helper function for POST request
    async function sendDataToServer(data) {
        try {
            const response = await fetch("http://localhost:3000/allocate", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(data),
            });

            if (response.ok) {
                const result = await response.json();
                console.log("Server response:", result);
                alert("Data successfully sent to the server!");
            } else {
                const error = await response.json();
                console.error("Server error:", error);
                alert("Error occurred while sending data to the server.");
            }
        } catch (err) {
            console.error("Network error:", err);
            alert("Failed to connect to the server.");
        }
    }





    // Helper function for GET request
    // ! fetching timetable for section
    async function fetchDataFromServer(sectionMap) {
        console.log("I am in the method");
        const sectionId = document.getElementById("sectionId").value; // Get section ID from input
        const timetableContainer = document.getElementById("timetableContainer");

        timetableContainer.innerHTML = ""; // Clear any previous timetable

        console.log("in get", sectionMap);

        try {
            const response = await fetch(`http://localhost:3000/tt/${sectionId}`); // Fetch timetable for the entered section ID

            if (!response.ok) {
                const error = await response.json();
                timetableContainer.innerHTML = `<p style="color: red;">${error.message}</p>`;
                return;
            }

            const { timetable } = await response.json();
            console.log("tt is ", timetable);

            if (!timetable || timetable.length === 0) {
                timetableContainer.innerHTML = `<p>No timetable found for section ID: ${sectionId}</p>`;
                return;
            }

            const table = document.createElement("table");
            const headerRow = document.createElement("tr");

            const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]; // Days of the week

            // Create the first column header for the days of the week
            const dayHeader = document.createElement("th");
            dayHeader.textContent = "Day/Period";
            headerRow.appendChild(dayHeader);

            // Create period headers
            const periods = ["9:00-10:00", "10:00-11:00", "11:10-12:10", "12:55-1:55", "1:55-2:55", "2:55-3:45"];
            periods.forEach((period) => {
                const th = document.createElement("th");
                th.textContent = period;
                headerRow.appendChild(th);
            });

            table.appendChild(headerRow);

            // Add rows from the timetable
            timetable.forEach((row, index) => {
                const tableRow = document.createElement("tr");

                // Add day of the week (Monday to Friday)
                const dayCell = document.createElement("td");
                dayCell.textContent = days[index] || ''; // Add the day (e.g., Monday, Tuesday...)
                tableRow.appendChild(dayCell);

                row.forEach((cell) => {
                    const td = document.createElement("td");
                    const sid = sectionMap.get(sectionId);

                    if (sid && sid.has(cell)) {
                        const [subjectId, isLab] = sid.get(cell);
                        console.log("sub id..", subjectId.subjectId, "type of..", typeof (subjectId), "cell..", sid.get(cell));
                        td.textContent = subjectId.subjectId; // Display subject ID
                    } else {
                        td.textContent = "."; // Empty cell
                    }

                    tableRow.appendChild(td);
                });

                table.appendChild(tableRow);
            });

            timetableContainer.appendChild(table); // Append the table to the container
        } catch (error) {
            console.error("Error fetching timetable:", error);
            timetableContainer.innerHTML = `<p style="color: red;">An error occurred. Please try again later.</p>`;
        }
    }

    //! fetching timtebale for the individual faculty
    async function fetchTimetable() {
        const subjectId = document.getElementById("subIdInput").value.trim();
        if (!subjectId) {
            alert("Please enter a Subject ID.");
            return;
        }

        try {
            const response = await fetch(`http://localhost:3000/ft/${subjectId}`);

            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }

            const data = await response.json();

            if (!data || !data.subjectTimetable || data.subjectTimetable.length === 0) {
                alert("No timetable found for this subject.");
                return;
            }

            displayTimetable(data.subjectTimetable);
        } catch (error) {
            alert("Error fetching timetable: " + error.message);
            console.error("Fetch error:", error);
        }
    }


    // !displaying for individual faculty timetable
    function displayTimetable(timetableData) {
        const facultyTableContainer = document.getElementById("facultytable");
        facultyTableContainer.innerHTML = ""; // Clear previous table content

        // Create table element
        const table = document.createElement("table");

        // Create table header
        const headerRow = document.createElement("tr");

        // Days of the week for the first column
        const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];

        // Create the first column header for the days of the week
        const dayHeader = document.createElement("th");
        dayHeader.textContent = "Day/Period";
        headerRow.appendChild(dayHeader);

        // Create period headers
        const periods = ["9:00-10:00", "10:00-11:00", "11:10-12:10", "12:55-1:55", "1:55-2:55", "2:55-3:45"];
        periods.forEach((period) => {
            const th = document.createElement("th");
            th.textContent = period;
            headerRow.appendChild(th);
        });

        table.appendChild(headerRow);

        // Create a 5x6 empty grid (5 rows for days, 6 columns for periods)
        const timetableGrid = Array.from({ length: 5 }, () => Array(6).fill(""));

        timetableData.forEach(section => {
            section.matchingSlots.forEach(slot => {
                const { row, col } = slot;

                // Ensure the slot coordinates are within the timetable grid (5 rows, 6 columns)
                if (row >= 0 && row < 5 && col >= 0 && col < 6) {
                    timetableGrid[row][col] = section.sectionId; // Place the sectionId in the corresponding cell
                }
            });
        });

        // Populate the table with the timetable grid
        timetableGrid.forEach((row, rowIndex) => {
            const tr = document.createElement("tr");

            // Add the day (Monday to Friday) to the first column
            const dayCell = document.createElement("td");
            dayCell.textContent = daysOfWeek[rowIndex]; // Get the day based on row index
            tr.appendChild(dayCell);

            // Add the period slots (columns)
            row.forEach(cell => {
                const td = document.createElement("td");
                td.textContent = cell || ''; // If no sectionId, leave the cell empty
                tr.appendChild(td);
            });

            table.appendChild(tr);
        });

        // Append the table to the facultytable div
        facultyTableContainer.appendChild(table);
        table.style.display = "table";  // Display the table
    }





    // Page-specific logic
    // var sectionMap = new Map(); // Map<SecId, Map<FacultyId, [{ subjectId, isLab }]>>

    if (document.title === "Sending") {
        // Logic for the page where data is sent to the server
        const addSubjectButton = document.getElementById("addSubject");
        const sendDataButton = document.getElementById("sendData");
        const outputElement = document.getElementById("output");

        const sectionMap = new Map(); // Map<SecId, Map<FacultyId, [{ subjectId, isLab }]>>

        // Add subject to sectionMap
        addSubjectButton.addEventListener("click", () => {
            const sectionId = String(document.getElementById("sectionId").value.trim());
            const facultyId = parseInt(document.getElementById("facultyId").value, 10);
            const subjectId = String(document.getElementById("subjectId").value.trim());
            const isLab = document.getElementById("isLab").value === "true";

            if (!sectionId || isNaN(facultyId) || !sectionId) {
                alert("Please enter valid inputs for Section ID, Faculty ID, and Subject ID.");
                return;
            }
            // ! appearing but subjectId is puyshed into json
            // Initialize nested Map for section if it doesn't exist
            if (!sectionMap.has(sectionId)) {
                sectionMap.set(sectionId, []);
            }
            const sectionData = sectionMap.get(sectionId);

            // Check if the subject already exists in the section
            let existingSubject = sectionData.find((sub) => sub.subjectId === subjectId);

            if (!existingSubject) {
                existingSubject = { subjectId, facultyId: [], isLab };
                sectionData.push(existingSubject);
            }

            // Add facultyId to the subject
            if (!existingSubject.facultyId.includes(facultyId)) {
                existingSubject.facultyId.push(facultyId);
            }

            // Convert sectionMap to output format
            // const result = Array.from(sectionMap.entries()).map(([section, subjects]) => ({
            //     section,
            //     orderedSubjects: subjects
            // }));
            //console.log("type...........", typeof (facultyId))
            const result = Array.from(sectionMap.entries()).map(([section, subjects]) => ({
                section,
                orderedSubjects: subjects.map(({ subjectId, facultyId, isLab }) => ({
                    facultyId,   // Only include facultyId
                    isLab        // Only include isLab
                }))
            }));


            outputElement.textContent = JSON.stringify(result, null, 2);
            console.log(result);
        });

        // Send data to the server
        sendDataButton.addEventListener("click", async () => {
            // Prepare data in the desired format
            // Prepare data in the desired format
            const data = [];

            for (const [sectionId, facultyMap] of sectionMap.entries()) {
                // Check if section already exists in data
                let sectionEntry = data.find(entry => entry.section === sectionId);

                if (!sectionEntry) {
                    sectionEntry = {
                        section: sectionId,
                        orderedSubjects: []
                    };
                    data.push(sectionEntry);
                }


                for (const [facultyId, facultySubjects] of facultyMap.entries()) {
                    console.log("facultySubjects:", facultySubjects, "Type:", typeof facultySubjects);

                    // Make sure facultySubjects is an array
                    const subjectsArray = Array.isArray(facultySubjects) ? facultySubjects : [facultySubjects];

                    subjectsArray.forEach(subject => {
                        // Ensure facultyId is in an array format (if it's not already)
                        const facultyIds = Array.isArray(subject.facultyId) ? subject.facultyId : [subject.facultyId];

                        // Now push the entire array [facultyIds] (if it's not already) directly to orderedSubjects
                        sectionEntry.orderedSubjects.push({
                            facultyId: facultyIds,  // Push the facultyIds array directly
                            isLab: subject.isLab
                        });
                    });
                }

            }


            //console.log(sectionMap)
            // POST Page
            let storedData = localStorage.getItem("sectionMap");
            let existingSectionMap = new Map();

            if (storedData) {
                existingSectionMap = new Map(
                    JSON.parse(storedData).map(([sectionId, facultyObj]) => [
                        sectionId,
                        new Map(Object.entries(facultyObj)), // Convert inner Object back to Map
                    ])
                );
            }

            // Merge new sectionMap into existingSectionMap
            for (const [sectionId, facultyMap] of sectionMap.entries()) {
                if (!existingSectionMap.has(sectionId)) {
                    existingSectionMap.set(sectionId, facultyMap);
                } else {
                    const existingFacultyMap = existingSectionMap.get(sectionId);
                    for (const [facultyId, subjects] of facultyMap.entries()) {
                        if (!existingFacultyMap.has(facultyId)) {
                            existingFacultyMap.set(facultyId, subjects);
                        } else {
                            existingFacultyMap.get(facultyId).push(...subjects);
                        }
                    }
                }
            }

            // Store updated sectionMap in localStorage
            localStorage.setItem(
                "sectionMap",
                JSON.stringify(
                    Array.from(existingSectionMap.entries()).map(
                        ([sectionId, facultyMap]) => [
                            sectionId,
                            Object.fromEntries(facultyMap), // Convert inner Map to Object
                        ]
                    )
                )
            );
            console.log("in post", sectionMap)

            console.log("data is ", data, "type of", typeof data)
            sendDataToServer(data);// Call POST function
        });
    }
    else if (document.title === "Fetching") {
        // Logic for the page where data is fetched from the server
        console.log("i am in fetching")
        const fetchDataButton = document.getElementById("timetableForm")
        // GET Page
        const storedSectionMap = localStorage.getItem("sectionMap");
        if (storedSectionMap) {
            sectionMap = new Map(
                JSON.parse(storedSectionMap).map(([sectionId, facultyObj]) => [
                    sectionId,
                    new Map(Object.entries(facultyObj)), // Convert inner Object back to Map
                ])
            );
            console.log("Retrieved Section Map:", sectionMap);
        }

        fetchDataButton.addEventListener("submit", (event) => {
            event.preventDefault();
            fetchDataFromServer(sectionMap);  // Now it will have the correct data
        });

    }
    else if (document.title === "Faculty Timetable") {
        document.getElementById("btn").addEventListener("click", (event) => {
            event.preventDefault();
            fetchTimetable();
        });
    }
});